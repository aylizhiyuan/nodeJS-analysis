## nodeJS核心知识整理


### 1. 理解js中的执行上下文（程序执行中栈空间的分配情况）

### 2. nodeJS中的eventLoop（异步实现）

#### 浏览器的异步实现原理

#### nodeJS中的libuv异步实现原理

### 3. nodeJS中的流

### 4. nodeJS中的模块化思想

### 5. nodeJS中的异步Promise/async/await

### 6. nodeJS如何实现高并发

### 7. 如何分析nodeJS中的内存泄漏

牢记内存四区:全局区、代码区、堆区、栈区

全局区的变量是在程序执行完毕后释放的，也就是你关闭页面后消失的。而栈里面的数据是当函数执行完毕后浏览器自动回收的

堆区的变量是需要手动回收的，代码区存放一条一条执行的指令

程序执行过程中的栈结构:main函数位于栈底---->执行一个函数就压入栈（函数的栈帧）----->函数参数首先入栈 -----> 返回地址入栈 ------> 被保存的寄存器的值（main函数中可能有些值是存在寄存器中的，所以要保存一下）-----> 局部变量 -----> 参数构造区(该函数要传递出去的参数)


内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况

内存泄漏的几种情况:

1) 全局变量

        a = 10;
        global.b = 11; 

这种比较简单的原因，是因为全局的变量只能在代码执行完毕后才会被清除掉

2) 闭包

        function out(){
            const bigData = new Buffer(10);
            inner = function(){
                void bigData;
            }
        }

闭包会引用到父级函数中的变量，如果闭包未被释放，就会导致内存泄漏。上面的例子是inner直接挂在了root上，从而导致内存泄漏(bigData不会释放)

3） 事件监听

事件监听也可能出现内存泄漏。例如对同一个事件重复监听，忘记移除，将造成内存泄漏。例如nodejs中的Agent的keep-alive为true的时候

分析nodeJS中的内存泄漏可以通过内存快照来查看

### 8. nodeJS进程


#### 进程的概念

一个进程指的是一个正在运行的程序。一个正在运行的程序在内存中的情况:
内核内存(对用户来说不可见) ----> 用户栈(运行的时候创建) ----> 共享库的内存映射区域（程序如果有动态库的话） ----> 运行时的堆（程序员自己分配的内存空间） ----> 读/写段（已经初始化未初始化的全局静态变量） ----> 只读代码段（常量、只读数据、程序代码）

以上可以简称：内存四区

#### 进程和线程的区别

计算机的核心是cpu,它承担了所有的计算任务,它就像是一个工厂，时刻都在运行

假定工厂的电力有限，一次只能供给一个车间使用，也就是说，一个车间开工的时候，其他的车间都必须停工，背后的含义就是单个cpu一次只能运行一个任务

进程就好比工厂的车间，它代表cpu所能处理的单个任务，任一时刻，cpu总是运行一个进程，其他进程处于非运行状态

这就是并发，就是同一时刻只有一个任务在执行，因为速度太快所以感觉好像在同时发生一样。并行才是真正的同一时刻同时执行两个任务

工厂的车间之间可以独立生产，也可以协作生产，但同一时刻，只能有一个车间在生产，这就涉及到进程之间的通信问题

进程的通信分为以下几个方法：1. 管道  2. 信号  3. 共享内存  4. 消息队列

一个车间内，可以有很多工人，他们协同完成一个任务

线程好比车间里面的工人，一个进程可以有多个线程，并且这些线程可以同一时刻一起运行，就是并行

车间的空间是工人们共享的，比如很多房间是每个工人都可以进入的。这象征着一个进程的内存空间是共享的。每个线程都可以使用这些共享内存

可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表着一个线程使用某些共享内存的时候，其他的线程只能等待它结束才能使用这一块内存

这就涉及到线程同步的必要性，当多个线程共享相同的内存的时候，需要每一个线程看到相同的视图，当一个线程修改变量的时候，其他的线程也可以读取读取或者修改这个变量。就需要对线程进行同步，确保他们不会访问到无效的变量

一个防止他人进入的简单方法，就是门口加一把锁，先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去，这就是互斥锁，防止多个线程同时读写某一块内存区域

有时候你会好奇线程有堆栈吗？其实是有栈，并且这个栈是放在进程堆空间中分配的


#### nodeJS里面的多进程







####  解决高并发的方案

高并发：在极短的单位时间内，极多个请求同时发起到服务器

服务器的压力会很大，然后，数据库的压力也会很大，所以，解决的思路应该放在服务器上（软件和硬件）和数据库（设计和查询）上面

高并发的服务器使用的是epoll（nginx的策略）,不是所谓的多进程和多线程,这个需要注意！！！！具体的实现可以看我的网络文档

1.分布式缓存：redis、memcached等，结合CDN来解决图片文件等访问。

2.消息队列中间件：activeMQ等，解决大量消息的异步处理能力。（这里可以参考下我设计的社区系统，用户登录成功后，又要检查用户信息、又要发送邮箱、最后还要检查是否有该用户的消息，这些连续的操作用消息队列再合适不过了）

3.应用拆分:一个工程被拆分为多个工程部署，利用dubbo解决多工程之间的通信。

4.数据库垂直拆分和水平拆分(分库分表)等。

5.数据库读写分离，解决大数据的查询问题。

6.还可以利用nosql ，例如mongoDB配合mysql组合使用。

7.还需要建立大数据访问情况下的服务降级以及限流机制等








